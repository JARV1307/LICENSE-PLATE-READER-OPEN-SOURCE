# -*- coding: utf-8 -*-
"""DETECTOR_LECTOR_MATRICULAS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14B3P4m7MmhZVLbhe32Kd_7e2ctTjroHE
"""

!pip install roboflow
!pip install opencv-python
!pip install easyocr

import os
import cv2
import numpy as np
from google.colab.patches import cv2_imshow
from roboflow import Roboflow
import string
import easyocr
import skimage

import re

def formato_matricula(text,tipo_matricula):
    """
       Aplica formatos al texto de la matrícula mediante la conversión de caracteres utilizando los diccionarios de mapeo.

    Args:
        text (str): Texto de la matrícula.

    Devuelve:
        str: Texto de la matrícula con el formato deseado.
    """
    if tipo_matricula==1:

      license_plate_ = ''
      mapping = {0: dict_char_to_int, 1:dict_char_to_int, 4: dict_int_to_char, 5: dict_int_to_char, 6: dict_int_to_char,
               2: dict_char_to_int, 3: dict_char_to_int}
      for j in [0, 1, 2, 3, 4, 5, 6]:
          if text[j] in mapping[j].keys():
              license_plate_ += mapping[j][text[j]]
          else:
              license_plate_ += text[j]

      return license_plate_

    return text

def check_formato_matricula(text):
    """
    comprueba que el texto obtenido por la lectura del OCR tenga el formato esperado de la matricula

    argumeto:
        texto (str): texto de la matricula

    returns:
        bool: True si el texto coincide con el formato esperado caso contrario False
    """
    matricula_antigua=0
    matricula_nueva=1


    #longitud de la matricula debe tener 7 caracteres
    if len(text) != 7:
        return False,None

    if (text[0] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'] or text[0] in dict_char_to_int.keys()) and \
       (text[1] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'] or text[1] in dict_char_to_int.keys()) and \
       (text[2] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'] or text[2] in dict_char_to_int.keys()) and \
       (text[3] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'] or text[3] in dict_char_to_int.keys()) and \
       (text[4] in string.ascii_uppercase or text[4] in dict_int_to_char.keys()) and \
       (text[5] in string.ascii_uppercase or text[5] in dict_int_to_char.keys()) and \
       (text[6] in string.ascii_uppercase or text[6] in dict_int_to_char.keys()):
       return True,matricula_nueva

    elif (text[4] in string.ascii_uppercase or text[4] in dict_int_to_char.keys())  and \
       (text[1] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'] or text[1] in dict_char_to_int.keys()) and \
       (text[2] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'] or text[2] in dict_char_to_int.keys()) and \
       (text[3] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'] or text[3] in dict_char_to_int.keys()) and \
       (text[3] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'] or text[3] in dict_char_to_int.keys()) and \
       (text[5] in string.ascii_uppercase or text[5] in dict_int_to_char.keys()) and \
       (text[6] in string.ascii_uppercase or text[6] in dict_int_to_char.keys()):
       return True, matricula_antigua

    else:
        return False,None

# initializar el lector OCR
reader = easyocr.Reader(['en'], gpu=True,)

# diccionarios para el mapeo de caracteres
dict_char_to_int = {'O': '0',
                    'I': '1',
                    'J': '3',
                    'L': '4',
                    'G': '6',
                    'S': '5'}

dict_int_to_char = {'0': 'O',
                    '1': 'I',
                    '3': 'J',
                    '4': 'A',
                    '6': 'G',
                    '5': 'S'}

def lector_matricula(roi_matricula):
    """
    funcion para lectura de la imagen recortada donde se encuentra la matricula

    argumento:
        recibe imagen recortada que alberga la matricula.

    returns:
        una tupla con el texto interpretado de la imagen de la matricula, acompañado de el porcentaje de confiabilidad
    """

    detections = reader.readtext(roi_matricula,batch_size=10)
    print(detections)

    for detection in detections:
        bbox, text, score = detection


        text = text.upper().replace(' ', '')
        #eliminar si detecta caracteres especiales
        text = re.sub(r'[^a-zA-Z0-9]', '', text)

        if text!='' or text!=None:
          if (len(text) > 7) and (text[0]=='1'):
            lista_cadena = list(text)
            lista_cadena[0] = ''
            text = ''.join(lista_cadena)

          if (len(text) > 7) and (text[0]=='E'):
            lista_cadena = list(text)
            lista_cadena[0] = ''
            text = ''.join(lista_cadena)

        print(text)

        check,tipo=check_formato_matricula(text)

        if check:
          return formato_matricula(text,tipo), score

    return None, None

def preprocess_image_4(image):

  if image is None or image.size == 0:  # comprueba si la imagen esta vacia
    print("Error: preprocess_image_4")  # Mensaje de error
    return None

  # Convertir a escala de grises
  gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

  # Aplicar la binarización mediante Otsu para obtener un fondo blanco y caracteres oscuros
  _, binary = cv2.threshold(gray, 180, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

  # Invertir la imagen para obtener caracteres oscuros sobre fondo blanco
  inverted = cv2.bitwise_not(binary)

  return inverted

def deteccion_matricula(path,model):

  #deteccion de la ubicacion de la matricula en la imagen
  caracteristicas=model.predict(path, confidence=60, overlap=30).json() #con una confianza del 60% minimo

  #desempaquetar coordenadas de la ubicacion de la matricula en la imagen
  #x,y,w,h,conf,clase,claseID,path,predict=caracteristicas['predictions'].values()[0]
  for prediction in caracteristicas['predictions']:
    x = prediction['x']
    y = prediction['y']
    w = prediction['width']
    h = prediction['height']


  #calculo de puntos del ROI
  roi_x = int(x-w / 2)+97
  roi_y = int(y-h / 2)+50
  roi_width = int(w)-139
  roi_height = int(h)-90

  #la resta fue un ajuste propio para recortar centrar lo mejor posible en los caracteres de la matricula

  #creacion de la ROI de matricula

  imagen = cv2.imread(path)

  roi_matricula = imagen[roi_y:roi_y+roi_height, roi_x:roi_x+roi_width]
  cv2.rectangle(imagen, (roi_x, roi_y), (roi_x+roi_width, roi_y+roi_height), (0, 255, 0), 2)


  roi_procesada=preprocess_image_4(roi_matricula)


  roi_procesada=skimage.segmentation.clear_border(roi_procesada)
  inverted = cv2.bitwise_not(roi_procesada)

  #mostrar ROIs
  cv2_imshow(roi_matricula)
  cv2_imshow(inverted)



  return lector_matricula(inverted)#texto_matricula


rf = Roboflow(api_key="63d1a9aEZEaXTBeLdSq4")
project = rf.workspace().project("license-plate-recognition-rxg4e")
model = project.version(4).model


lista_matriculas=[]

input_dir = '/content/drive/MyDrive/Imagenes_proyecto_SMA (1)/Imagenes_proyecto_SMA'
for img_name in os.listdir(input_dir):

    img_path = os.path.join(input_dir, img_name)
    lista_matriculas.append(deteccion_matricula(img_path,model)[0])

    print(img_path)

lista_matriculas

nueva_lista = [valor for valor in lista_matriculas if valor is not None]

print(nueva_lista)

len(nueva_lista)
